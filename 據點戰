#include <iostream>
#include <algorithm>
#include<vector>
#include<cstring>
#include<queue>
#include<cmath>
using namespace std;

#define eps 1e-6
struct edge {
	int u, v, cap, flow,cost;
};
vector<edge>E;
vector<int>g[50];
int T;
void add(int u, int v, int cap, int cost) {
	E.push_back(edge{ u,v,cap,0,cost });
	E.push_back(edge{ v,u,0,0,-cost });
	int m = E.size();
	g[u].push_back(m - 2);
	g[v].push_back(m - 1);
}
int n, m;
int s, t;
void init() {
	for (int i = s; i <= t; i++)g[i].clear();
	E.clear();
}
int d[50],r[50],last;
int inq[50], pre[50],a[50];//inqueue pre residue
int suc;
bool SPFA(int &flow, int &c) {
	for (int i = 0; i <= t; i++)inq[i] = pre[i] = a[i] = 0;
	for (int i = 0; i <= t; i++)d[i] = 1e9;
	d[s] = 0;
	a[s] = 1e9;	queue<int>q;
	q.push(s);
	while (!q.empty()) {
		int u = q.front(); q.pop();
		inq[u] = 0;
		for (int i = 0; i < g[u].size(); i++) {
			edge &e = E[g[u][i]];
			if (e.cap > e.flow&&d[e.v] > d[e.u] + e.cost+eps) {
				d[e.v] = d[e.u] + e.cost;
				r[e.v] = e.cost;
				a[e.v] = min(a[e.u], e.cap - e.flow);
				pre[e.v] = g[u][i];
				if (!inq[e.v]) {
					inq[e.v] = 1;
					q.push(e.v);
				}
			}
		}
	}
	if (d[t] == 1e9)return 0;
	flow += a[t];
	if (d[t] != r[E[pre[t]].u]) {
		int pc = r[r[E[pre[t]].u]];
		if (d[t] - r[E[pre[t]].u] + -pc > T)suc--;
		//last = d[t] * a[t];
	}
	c += d[t] * a[t];//迴朔沖減 相當於 假設原本 n=3 m=4 n1->m2 4  n1->m1 10   把他從m1->m2 只要多加 10-4 因此以 6來處理 
	if (r[E[pre[t]].u] <= T)suc++;
	for (int i = t; i != s; i = E[pre[i]].u) {
		E[pre[i]].flow += a[t];
		E[pre[i] ^ 1].flow -= a[t];
	}
	return 1;
}

int MCMF() {
	int  c = 0, flow = 0;
	while (SPFA(flow, c));
	return c;
}
int main() {
	while (cin >> n >> m >> T, n) {
		s = suc = 0, t = n + m + 1;
		init();
		int tt;
		for (int i = 1; i <= n; i++) {
			add(0, i, 1, 0);
			for (int j = 1; j <= m; j++) {
				cin >> tt;
				add(i, n + j, 1, tt);
			}
		}
		for (int j = 1; j <= m; j++)
			add(j + n, t, 1, 0);
		double p=MCMF();
		printf("%.2lf %d\n", p/n + 0.001,suc);//精度到小數點2位所以加1e-3
	}
}
